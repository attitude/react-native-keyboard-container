// flow-typed signature: df6af66830e878fa57e0d7634bc15d82
// flow-typed version: <<STUB>>/react-native_v0.55.4/flow_v0.73.0

/**
 * This is an autogenerated libdef stub for:
 *
 *   'react-native'
 *
 * Fill this stub out by replacing all the `any` types.
 *
 * Once filled out, we encourage you to share your work with the
 * community by sending a pull request to:
 * https://github.com/flowtype/flow-typed
 */

import React from 'react';

declare module 'react-native' {
  declare type StyleId = number;
  declare type StyleRules = Object;
  declare type Styles = {[key: string]: StyleRules};
  declare type StyleRuleSet<S: Styles> = {[key: $Keys<S>]: StyleId};
  declare type StyleProp = false | null | void | StyleId | Styles | Array<StyleProp>;

  declare type ValueListenerCallback = (state: {value: number}) => void;
  declare type ValueXYListenerCallback = (value: {x: number, y: number}) => void;

  declare class Dimensions {
    static get(dim: string): {
      height: number,
      width: number,
    },
  }

  declare type CompositeAnimation = {
    start: (callback?: ?EndCallback) => void,
    stop: () => void,
    reset: () => void,
  };

  declare type ViewLayout = {
    x: number,
    y: number,
    width: number,
    height: number,
  }

  declare type ViewLayoutEvent = {
    nativeEvent: {
      layout: ViewLayout,
    }
  }

  declare type ExtrapolateType = 'extend' | 'identity' | 'clamp';
  declare type InterpolationConfigType = {
    inputRange: Array<number>,
    outputRange: (Array<number> | Array<string>),
    easing?: ((input: number) => number),
    extrapolate?: ExtrapolateType,
    extrapolateLeft?: ExtrapolateType,
    extrapolateRight?: ExtrapolateType,
  };
  declare type EndResult = {finished: bool};
  declare type EndCallback = (result: EndResult) => void;
  declare type AnimationConfig = {
    isInteraction?: bool,
    useNativeDriver?: bool,
    onComplete?: ?EndCallback,
    iterations?: number,
};

  declare class Interpolation {
    static create(config: InterpolationConfigType): (input: number) => number | string,
  }

  declare class BaseAnimated {}

  declare class Animation {
    start(
      fromValue: number,
      onUpdate: (value: number) => void,
      onEnd: ?EndCallback,
      previousAnimation: ?Animation,
      animatedValue: AnimatedValue
    ): void,
    onUpdate(): void,
    stop(): void,
  }

  declare class AnimatedWithChildren extends BaseAnimated {}

  declare class AnimatedInterpolation extends AnimatedWithChildren {
    constructor(parent: BaseAnimated, config: InterpolationConfigType): void,
    interpolate(config: InterpolationConfigType): AnimatedInterpolation,
  }

  declare class AnimatedValue extends AnimatedWithChildren {
    constructor(value: number): void,
    setValue(value: number): void,
    setOffset(offset: number): void,
    flattenOffset(): void,
    extractOffset(): void,
    addListener(callback: ValueListenerCallback): string,
    removeListener(id: string): void,
    removeAllListeners(): void,
    stopAnimation(callback?: ?(value: number) => void): void,
    resetAnimation(callback?: ?(value: number) => void): void,
    interpolate(config: InterpolationConfigType): AnimatedInterpolation,
    animate(animation: Animation, callback: ?EndCallback): void,
    stopTracking(): void,
    track(tracking: BaseAnimated): void,
  }

  declare class AnimatedValueXY extends AnimatedWithChildren {
    x: AnimatedValue;
    y: AnimatedValue;
    constructor(valueIn?: ?{x: number | AnimatedValue, y: number | AnimatedValue}): void,
    setValue(value: {x: number, y: number}): void,
    setOffset(offset: {x: number, y: number}): void,
    flattenOffset(): void,
    extractOffset(): void,
    resetAnimation(callback?: (value: {x: number, y: number}) => void): void,
    stopAnimation(callback?: (value: {x: number, y: number}) => void): void,
    addListener(callback: ValueXYListenerCallback): string,
    removeListener(id: string): void,
    removeAllListeners(): void,
    getLayout(): {[key: string]: AnimatedValue},
    getTranslateTransform(): Array<{[key: string]: AnimatedValue}>,
  }

  declare var Animated: {
    Value: any,
    View: any,
    timing: (value: AnimatedValue | AnimatedValueXY, config: any /*TimingAnimationConfig*/) => CompositeAnimation
  }

  declare var Platform: {|
    OS: 'ios' | 'android',
    Version: number,
    isPad: boolean,
    isTesting: boolean,
    isTVOS: boolean,
    select<T>(obj: { [key: string]: T }): T,
  |}

  declare var ImageStylePropTypes: any;
  declare var TextStylePropTypes: any;
  declare var ViewStylePropTypes: any;

  declare type KeyboardEventName =
    | 'keyboardWillShow'
    | 'keyboardDidShow'
    | 'keyboardWillHide'
    | 'keyboardDidHide'
    | 'keyboardWillChangeFrame'
    | 'keyboardDidChangeFrame';

  declare type ScreenRect = $ReadOnly<{|
    screenX: number,
    screenY: number,
    width: number,
    height: number,
  |}>;

  declare export type KeyboardEvent = $ReadOnly<{|
    duration?: number,
    easing?: string,
    endCoordinates: ScreenRect,
    startCoordinates?: ScreenRect,
  |}>;

  declare class View extends React$Component<*> {}
  declare class TouchableWithoutFeedback extends React$Component<*> {}
  declare class TouchableOpacity extends React$Component<*> {}
  declare class Text extends React$Component<*> {}

  declare var NativeModules: any;

  declare class EventSubscriptionVendor {
    constructor(): void;
    addSubscription(
      eventType: string,
      subscription: EventSubscription,
    ): EventSubscription;
    removeAllSubscriptions(eventType: ?string): void;
    removeSubscription(subscription: Object): void;
    getSubscriptionsForType(eventType: string): ?[EventSubscription];
  }

  declare class EventSubscription {
    eventType: string;
    key: number;
    subscriber: EventSubscriptionVendor;
    constructor(subscriber: EventSubscriptionVendor): void;
    remove(): void;
  }

  declare class EmitterSubscription extends EventSubscription {
    constructor(
      emitter: EventEmitter,
      subscriber: EventSubscriptionVendor,
      listener: Function,
      context: ?Object,
    ): void;
    remove(): void;
  }

  declare class EventEmitter {
    constructor(subscriber: ?EventSubscriptionVendor): void;
    addListener(
      eventType: string,
      listener: Function,
      context: ?Object,
    ): EmitterSubscription;
    once(
      eventType: string,
      listener: Function,
      context: ?Object,
    ): EmitterSubscription;
    removeAllListeners(eventType: ?string): void;
    removeCurrentListener():void;
    removeSubscription(subscription: EmitterSubscription): void;
    listeners(eventType: string): [EmitterSubscription];
    emit(eventType: string, ...rest: any): void;
    removeListener(eventType: String, listener: Function): void;
  }

  declare type NativeModule = {
    +addListener: (eventType: string) => void,
    +removeListeners: (count: number) => void,
  };
  declare class NativeEventEmitter extends EventEmitter {
    constructor(nativeModule: ?NativeModule): void;
    addListener(
      eventType: string,
      listener: Function,
      context: ?Object,
    ): EmitterSubscription;
    removeAllListeners(eventType: ?string): void;
    removeSubscription(subscription: EmitterSubscription): void;
  }

  declare class Modal extends React$Component<{
    visible?: boolean,
    supportedOrientations?: ('portrait' | 'portrait-upside-down' | 'landscape' | 'landscape-left' | 'landscape-right')[],
    onRequestClose: () => void,
    onShow: () => void,
    transparent?: boolean,
    animationType?: 'slide' | 'fade' | 'none',
    hardwareAccelerated?: boolean,
    onDismiss?: () => void,
    onOrientationChange?: () => void,
    presentationStyle?: 'fullScreen' | 'pageSheet' | 'formSheet' | 'overFullScreen',
  }> {}

  declare class StyleSheet {
    static setStyleAttributePreprocessor(property: string, process: (property: string) => mixed): void;
    static create(obj: Styles): StyleRuleSet<Styles>;
    static flatten(style: StyleRuleSet<Styles>): Styles;
    static +hairlineWidth: number;
    static +absoluteFill: Styles;
    static +absoluteFillObject: StyleRules;
  }
}
